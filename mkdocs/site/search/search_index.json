{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#map-everything-with-kmap-a-flexible-and-powerful-compose-multiplatform-mapping-library","title":"Map everything with KMaP: A flexible and powerful compose multiplatform mapping library","text":""},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Cross-Platform Compatibility: Use a single KMaP Composable in your common code for a consistent user experience across all platforms.</li> <li>Customizable Map Styles: Ability to customize the appearance of maps, including colors, labels, and themes.</li> <li>Interactive Elements: Features like zooming, panning, and rotating maps.</li> <li>Marker and Popup Support: Adding markers, popups, and tooltips to maps for enhanced interactivity.</li> <li>Layer Management: Support for multiple layers, including vector and raster layers.</li> <li>Clustering: Visualizing data density with clustering markers.</li> <li>Offline Maps: Ability to use maps without an internet connection.</li> <li>Projection Support: Handling different map projections and coordinate systems.</li> <li>Performance: Efficient rendering and handling of large datasets.</li> <li>Easy Integration: Seamlessly integrate KMaP into your existing projects.</li> <li>Customizable: Tailor the map's appearance and behavior to fit your needs.</li> </ul>"},{"location":"#usage-example","title":"Usage Example","text":"<p>With KMaP, you don't need a mapping source for each platform. Here's a simple example to get you started:</p> <pre><code>val motionController = rememberMotionController()\nval mapState = rememberMapState(mapProperties = OSMMapProperties())\n\nKMaP(\n    modifier = Modifier.size(300.dp, 600.dp),\n    motionController = motionController,\n    mapState = mapState,\n    canvasGestureListener = DefaultCanvasGestureListener()\n) {\n    canvas(tileSource =  OSMTileSource::getTile)\n}\n</code></pre>"},{"location":"setup/","title":"Setup","text":"<ol> <li> <p>Add Maven Central to your repositories if needed</p> <p><pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> 2. Add the desired dependencies to your module's <code>build.gradle</code> file</p> </li> </ol> DependenciesVersion Catalog <pre><code>  sourceSets {\n    val kmapVersion =\"0.1.0\"\n    commonMain.dependencies {\n        implementation(\"com.rafambn.kmap:kmap:$kmapVersion\")\n    }\n\n    androidMain.dependencies {\n        implementation(\"com.rafambn.kmap:kmap-android:$kmapVersion\")\n    }\n\n    jvmMain.dependencies {\n        implementation(\"com.rafambn.kmap:kmap-jvm:$kmapVersion\")\n    }\n\n    jsMain.dependencies {\n        implementation(\"com.rafambn.kmap:kmap-js:$kmapVersion\")\n    }\n\n    iosMain.dependencies {\n        implementation(\"com.rafambn.kmap:kmap-ios:$kmapVersion\")\n    }\n}\n</code></pre> <pre><code>[versions]\nkmap = \"0.1.0\"\n\n[libraries]\nkmap = { module = \"com.rafambn.kmap:kmap\", version.ref = \"kmap\" }\nkmap-android = { module = \"com.rafambn.kmap:kmap-android\", version.ref = \"kmap\" }\nkmap-jvm = { module = \"com.rafambn.kmap:kmap-jvm\", version.ref = \"kmap\" }\nkmap-ios = { module = \"com.rafambn.kmap:kmap-ios\", version.ref = \"kmap\" }\nkmap-js = { module = \"com.rafambn.kmap:kmap-js\", version.ref = \"kmap\" }\n</code></pre> <p>Current version here.</p>"},{"location":"usage/","title":"Usage","text":"<p>Here is a basic implementation of KMaP where it uses the OpenStreetMaps tile generation to show the map on the screen.</p> <p>The following Kotlin code demonstrates how to set up a motion controller and map state using the KMaP component. </p> <pre><code>val motionController = rememberMotionController()\nval mapState = rememberMapState(mapProperties = OSMMapProperties())\nKMaP(\n    modifier = Modifier.size(300.dp, 600.dp),\n    motionController = motionController,\n    mapState = mapState,\n    canvasGestureListener = DefaultCanvasGestureListener()\n) {\n    canvas(tileSource =  OSMTileSource::getTile)\n}\n</code></pre>"},{"location":"usage/#how-it-works","title":"How it Works","text":"<p>There are 4 components of the KMaP: MotionController, MapState, CanvasGestureListener and the Canvas.</p> <ul> <li>MotionController: Handle the movement of the map like zooming, panning, and rotating for either user input or app input.</li> <li>MapState: Control all properties of the map and defines the visible tiles for canvas rendering.</li> <li>CanvasGestureListener: Takes user inputs and process it to perform an action on the MotionController.</li> <li>Canvas: Render the visible tiles provide by the MapState based on a define the tile source, in this case above, using OSMTileSource::getTile built-in function.</li> </ul>"},{"location":"usage/#mapstate","title":"MapState","text":"<p>This is where all the magic happen. It expects an implementation MapProperties interface that will tell how the map will behave for example: tile size, zoom level and projection transformation function. <pre><code>interface MapProperties {\n    val boundMap: BoundMapBorder\n    val outsideTiles: OutsideTilesType\n    val zoomLevels: MapZoomLevelsRange\n    val mapCoordinatesRange: MapCoordinatesRange\n    val tileSize: Int\n\n    fun toCanvasPosition(projectedCoordinates: ProjectedCoordinates): CanvasPosition\n\n    fun toProjectedCoordinates(canvasPosition: CanvasPosition): ProjectedCoordinates\n}\n</code></pre> It will hold the angle, zoom, position variables and calculate the visible tiles so that each canvas could render its  own images.</p>"},{"location":"usage/#gesturelistener","title":"GestureListener","text":"<p>This open class is a basic implementation for handling user input, on the canvas only, like tap's, drag's and hover's,  and will interface with the MotionController to perform the desired action. If the developer desires it can override  this class and add its own custom actions while retaining if wanted the other functionalities.</p>"},{"location":"usage/#motioncontroller","title":"MotionController","text":"<p>It's responsible for handling the movement of the map like zooming, panning, and rotating for either user input or app input.</p> <p>It has 3 movement options:</p> <ul> <li>Set: This will set the map parameters with the provided values</li> <li>Scroll: This will add/remove the provided values from the map parameters</li> <li>Animate: This will animate the map parameters to the provided value</li> </ul> <p>While Set and Scroll are Synchronous the Animate is Async and thus must be launched from a coroutine.</p>"},{"location":"usage/#center-location","title":"Center Location","text":"<p>Before seeing how to set, scroll and animate you have to be aware of the CenterLocation. It's a sealed class of the Motion Controller that indicates reference points on the screen.</p> <pre><code>sealed class CenterLocation {\n    data class Position(val position: CanvasPosition) : CenterLocation()\n    data class Coordinates(val projectedCoordinates: ProjectedCoordinates) : CenterLocation()\n    data class Offset(val offset: ScreenOffset) : CenterLocation()\n}\n</code></pre> <ul> <li>Position represents a coordinates of the map without applying the projection</li> <li>Coordinates represents a coordinates of the map</li> <li>Offset represents a screen offset with 0 - 0 located on the top left part of the screen</li> </ul>"},{"location":"usage/#set-and-scroll","title":"Set and Scroll","text":"<p>Set and Scroll has its own scoped interface so it can only perform the following actions</p> <pre><code>interface MoveInterface {\n        fun center(center: CenterLocation)\n        fun zoom(zoom: Float)\n        fun zoomCentered(zoom: Float, center: CenterLocation)\n        fun angle(degrees: Double)\n        fun rotateCentered(degrees: Double, center: CenterLocation)\n    }\n</code></pre> <p>Here are some example for how to Set with MotionController. *See the comments to fully understand what each line does</p> <pre><code>motionController.set { \n   center(CenterLocation.Offset(ScreenOffset.Zero))  # (1)!\n   center(CenterLocation.Position(CanvasPosition.Zero)) # (2)!\n   center(CenterLocation.Coordinates(ProjectedCoordinates.Zero)) # (3)!\n   zoom(5F) # (4)!\n   zoomCentered(7F, CenterLocation.Position(CanvasPosition.Zero)) # (5)!\n   rotateCentered(45.0, CenterLocation.Offset(ScreenOffset.Zero)) # (6)!\n}\n</code></pre> <ol> <li>Center the current provided point of the screen in the center of the screen</li> <li>Center provided position of the canvas, without projection, in the center of the screen</li> <li>Center provided projection in the center of the screen</li> <li>Set the zoom amount</li> <li>Set the zoom amount, while maintaining the provide point of the same place on the screen</li> <li>Rotate the canvas around a provide pivot point</li> </ol>"},{"location":"usage/#animate","title":"Animate","text":"<p>Now here is the scoped interface with the functions that can be implemented with Animate and an example</p> <pre><code>interface AnimationInterface {\n    suspend fun positionTo(center: CenterLocation, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun positionBy(center: CenterLocation, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun zoomTo(zoom: Float, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun zoomBy(zoom: Float, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun zoomToCentered(zoom: Float, center: CenterLocation, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun zoomByCentered(zoom: Float, center: CenterLocation, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun angleTo(degrees: Double, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun angleBy(degrees: Double, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun rotateToCentered(degrees: Double, center: CenterLocation, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n    suspend fun rotateByCentered(degrees: Double, center: CenterLocation, decayRate: Double = 5.0, duration: MilliSeconds = 1000)\n}\n</code></pre> <p>Animate has similar scoped functions to set and scroll with a key difference. While Set and scroll have separated function for  moving to a place and moving by an amount, animate doesn't instead this difference can be seen in the scoped function key works to and by.</p> <pre><code>CoroutineScope(Dispatchers.Default).launch {\n    motionController.animate {\n        positionTo(CenterLocation.Offset(Offset(5F,5F)))\n        positionBy(CenterLocation.Offset(Offset(10F, 10F)))\n    }\n}\n</code></pre>"},{"location":"usage/#behavior","title":"Behavior","text":"<p>Because the Motion controller is initiated before the KMaP composable it creates scenarios in witch you mighty execute some  movement without the KMaP response. So to fix this all Synchronous functions, off type Set and Scroll, are placed in a queue, in the order you coded, and the last coroutine job declared is also stored to be executed when the composable comes to be. When this happens the Motion Controller will execute all Set's and Scroll's first them the Animate Job.</p> <p>After this initial phase, the movement will be executed on demand with a single difference that is if an Animate job is executing, and you Set or Scroll that this job will be cancelled and your Synchronous function will be executed.</p>"},{"location":"usage/#canvas","title":"Canvas","text":"<p>The Canvas function usable in the KMaP scope is just a wrapper on the native canvas so that we can handle the render  process the only thing you need to do its provide the source tile implementing the following api.</p> <pre><code>interface TileSource {\n    suspend fun getTile(zoom: Int, row: Int, column: Int): ResultTile\n}\n</code></pre> <p>With this simple trick you can render any tilled map you want. Maybe you want a free map off the world with OSM, or don't  like to use Google library but want to use its tiles, or render it on the device, or read from a local files for your  Skyrim map (I'm old sorry) with this you can do it all. </p> <p>See https://wiki.openstreetmap.org/wiki/Slippy_map for better understand how it works.</p>"},{"location":"usage/#built-in-sources","title":"Built-in Sources","text":"<ul> <li>OSM Mapnik</li> </ul>"},{"location":"usage/#offline","title":"Offline","text":"<p>For offline use you can either read from a .map file or a repo and render it with MapsForge or create your own renderer.</p> <p>Future versions will have both built-in</p>"},{"location":"usage/#markers","title":"Markers","text":""}]}